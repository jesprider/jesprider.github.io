{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 462095797e14a559096c","webpack:///./mob/js/app.js","webpack:///./mob/js/modules/game.js","webpack:///./mob/js/modules/config.js","webpack:///./mob/js/modules/input.js","webpack:///./mob/js/modules/artifact.js","webpack:///./mob/js/modules/balloon.js","webpack:///./mob/js/modules/touch.js","webpack:///./mob/js/modules/particle.js","webpack:///./mob/js/modules/draw.js","webpack:///./mob/js/modules/hitArtifact.js","webpack:///./mob/js/modules/collidesBalloon.js","webpack:///./mob/js/modules/pump.js","webpack:///./mob/js/modules/cloud.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","lastTime","vendors","x","length","window","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","now","timeToCall","Math","max","setTimeout","clearTimeout","game","addEventListener","init","resize","config","Input","Artifact","Balloon","Touch","Particle","Draw","hitArtifact","collidesBalloon","Pump","Cloud","hookjs","WIDTH","width","HEIGHT","height","scale","imageScale","offset","top","left","entities","clouds","nextArtifact","firstArtifact","blowing","needTutorial","score","taps","hit","escaped","accuracy","total","RATIO","currentWidth","currentHeight","canvas","ctx","ua","android","ios","eventType","e","preventDefault","set","touches","wh","innerHeight","ww","innerWidth","document","location","search","min","getElementsByTagName","getContext","navigator","userAgent","toLowerCase","indexOf","balloon","pump","pointerDisabled","msPointerEnabled","loop","body","style","hideLoading","offsetTop","offsetLeft","scrollTo","update","i","n","checkCollision","time","sin","timeOfBlowing","artifactCrashed","push","random","tapped","y","type","r","addParticles","remove","splice","isNaN","render","rect","bgColor","groundWidth","groundUpWidth","groundColorUp","groundDownWidth","groundColorDown","hoseWidth","hoseColor","platformWidth","platformHeight","text","tutorialColor","collides","animId","statusIndex","animalsNum","h","textColor","artifact","radius","strength","restart","tutorialQuantity","blowingSpeed","minIndex","unblowingIndex","waveRange","speedRange","quantity","heightOfAppearing","heightRange","animationSpeed","cloud","leftRange","leftOfAppearing","data","input","this","pageX","pageY","speed","picNum","floor","pic","Image","src","onload","w","naturalWidth","naturalHeight","initX","ratio","touch","opacity","fade","circle","col","particle","dir","vx","vy","clear","clearRect","fillStyle","fillRect","beginPath","arc","PI","closePath","fill","string","size","font","fillText","drawImage","a","b","centerArtifactX","centerArtifactY","distance_squared","radii_squared","centerBalloonX","centerBalloonY","pump1","pump2","dx","dy"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * RequestAnimationFrame polyfill\n\t */\n\tvar lastTime = 0;\n\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\tfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n\t    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n\t    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']\n\t                               || window[vendors[x]+'CancelRequestAnimationFrame'];\n\t}\n\n\tif (!window.requestAnimationFrame)\n\t    window.requestAnimationFrame = function(callback, element) {\n\t        var currTime = Date.now();\n\t        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t        var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n\t          timeToCall);\n\t        lastTime = currTime + timeToCall;\n\t        return id;\n\t    };\n\n\tif (!window.cancelAnimationFrame)\n\t    window.cancelAnimationFrame = function(id) {\n\t        clearTimeout(id);\n\t    };\n\n\tvar game = __webpack_require__(1);\n\n\twindow.addEventListener('load', game.init, false);\n\twindow.addEventListener('resize', game.resize, false);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar config = __webpack_require__(2);\n\tvar Input = __webpack_require__(3);\n\tvar Artifact = __webpack_require__(4);\n\tvar Balloon = __webpack_require__(5);\n\tvar Touch = __webpack_require__(6);\n\tvar Particle = __webpack_require__(7);\n\tvar Draw = __webpack_require__(8);\n\tvar hitArtifact = __webpack_require__(9);\n\tvar collidesBalloon = __webpack_require__(10);\n\tvar Pump = __webpack_require__(11);\n\tvar Cloud = __webpack_require__(12);\n\twindow.hookjs = window.hookjs || null;\n\n\tvar game = {\n\t    // set up some inital values\n\t    WIDTH: config.width,\n\t    HEIGHT: config.height,\n\t    scale: 1,\n\t    imageScale: 1,\n\t    // the position of the canvas\n\t    // in relation to the screen\n\t    offset: {top: 0, left: 0},\n\t    // store all artifacts, touches, particles etc\n\t    entities: [],\n\t    clouds: [],\n\t    // the amount of game ticks until\n\t    // we spawn a artifact\n\t    nextArtifact: config.firstArtifact,\n\t    blowing: false,\n\t    needTutorial: false,\n\t    // for tracking player's progress\n\t    score: {\n\t        taps: 0,\n\t        hit: 0,\n\t        escaped: 0,\n\t        accuracy: 0,\n\t        total: 0\n\t    },\n\t    // we'll set the rest of these\n\t    // in the init function\n\t    RATIO:  null,\n\t    currentWidth:  null,\n\t    currentHeight:  null,\n\t    canvas: null,\n\t    ctx:  null,\n\t    ua:  null,\n\t    android: null,\n\t    ios:  null,\n\n\t    init: function() {\n\t        var wh = window.innerHeight;\n\t        var ww = window.innerWidth;\n\n\t        if (wh/ww > 1 && ww < 767) {\n\t            game.WIDTH = ww * 2;\n\t            game.HEIGHT = wh * 2;\n\t        }\n\n\t        if (document.location.search === '?showtutorial') {\n\t            game.needTutorial = true;\n\t        }\n\n\t        // will think that 640 - normal height of canvas\n\t        game.imageScale = Math.min(wh / 640, 1);\n\n\t        // the proportion of width to height\n\t        game.RATIO = game.WIDTH / game.HEIGHT;\n\t        // these will change when the screen is resize\n\t        game.currentWidth = game.WIDTH;\n\t        game.currentHeight = game.HEIGHT;\n\t        // this is our canvas element\n\t        game.canvas = document.getElementsByTagName('canvas')[0];\n\t        // it's important to set this\n\t        // otherwise the browser will\n\t        // default to 320x200\n\t        game.canvas.width = game.WIDTH;\n\t        game.canvas.height = game.HEIGHT;\n\t        // the canvas context allows us to\n\t        // interact with the canvas api\n\t        game.ctx = game.canvas.getContext('2d');\n\t        // we need to sniff out android & ios\n\t        // so we can hide the address bar in\n\t        // our resize function\n\t        game.ua = navigator.userAgent.toLowerCase();\n\t        game.android = game.ua.indexOf('android') > -1 ? true : false;\n\t        game.ios = ( game.ua.indexOf('iphone') > -1 || game.ua.indexOf('ipad') > -1  ) ? true : false;\n\n\t        // Шарик и насос\n\t        game.balloon = new Balloon(game);\n\t        game.pump = new Pump(game);\n\n\t        function addEventListener(eventType) {\n\t            return function (e) {\n\t                e.preventDefault();\n\n\t                if (eventType === 'touchstart') {\n\t                    Input.set(game, e.touches[0]);\n\t                } else if (eventType === 'MSPointerDown') {\n\t                    Input.set(game, e);\n\t                } else {\n\t                    Input.set(game, e);\n\t                }\n\t            }\n\t        }\n\n\t        var pointerDisabled = function (e) {\n\t            e.preventDefault();\n\t        };\n\n\t        if ('ontouchstart' in window) {\n\n\t            window.addEventListener('touchstart', addEventListener('touchstart'), false);\n\t            window.addEventListener('touchmove', pointerDisabled, false);\n\t            window.addEventListener('touchend', pointerDisabled, false);\n\n\t        } else if (window.navigator && window.navigator.msPointerEnabled) {\n\n\t            window.addEventListener('MSPointerDown', addEventListener('MSPointerDown'), false);\n\t            window.addEventListener('MSPointerMove', pointerDisabled, false);\n\t            window.addEventListener('MSPointerUp', pointerDisabled, false);\n\n\t        } else {\n\n\t            window.addEventListener('mousedown', addEventListener('mousedown'), false);\n\t            window.addEventListener('mousemove', pointerDisabled, false);\n\t            window.addEventListener('mouseup', pointerDisabled, false);\n\n\t        }\n\n\n\t        // we're ready to resize\n\t        game.resize();\n\t        game.loop();\n\t    },\n\n\n\t    resize: function() {\n\t        if (game.currentWidth > window.innerWidth) {\n\t            game.currentWidth = window.innerWidth;\n\t            game.currentHeight = game.currentWidth / game.RATIO;\n\t        }\n\n\t        if (game.android || game.ios) {\n\t            document.body.style.height = (window.innerHeight + 50) + 'px';\n\t        }\n\n\t        game.currentHeight = window.innerHeight;\n\t        // check if we in android native app\n\t        if (window.hookjs && window.hookjs.hideLoading) {\n\t            game.currentHeight -= 50;\n\t        }\n\t        // resize the width in proportion\n\t        // to the new height\n\t        game.currentWidth = game.currentHeight * game.RATIO;\n\n\t        // set the new canvas style width & height\n\t        // note: our canvas is still 320x480 but\n\t        // we're essentially scaling it with CSS\n\t        game.canvas.style.width = game.currentWidth + 'px';\n\t        game.canvas.style.height = game.currentHeight + 'px';\n\n\t        // the amount by which the css resized canvas\n\t        // is different to the actual (480x320) size.\n\t        game.scale = game.currentWidth / game.WIDTH;\n\t        // position of canvas in relation to\n\t        // the screen\n\t        game.offset.top = game.canvas.offsetTop;\n\t        game.offset.left = game.canvas.offsetLeft;\n\n\t        window.setTimeout(function() {\n\t            window.scrollTo(0,1);\n\t        }, 1);\n\t    },\n\n\t    // this is where all entities will be moved\n\t    // and checked for collisions etc\n\t    update: function() {\n\t        var i, n;\n\t        var checkCollision = false; // we only need to check for a collision if the user tapped on this game tick\n\t        var time = Date.now() * 0.002;\n\n\t        game.blowing = Math.sin(time * config.timeOfBlowing) > 0; // используется для синхронизации насоса и шарика\n\t        game.artifactCrashed = false;\n\n\t        // decrease our nextBubble counter\n\t        game.nextArtifact -= 1;\n\t        // if the counter is less than zero\n\t        if (game.nextArtifact < 0) {\n\t            if (game.clouds.length < 2 && !game.needTutorial) {\n\t                game.clouds.push(new Cloud(game));\n\t            }\n\t            // put a new instance of bubble into our entities array\n\t            game.entities.push(new Artifact(game));\n\t            game.score.total += 1;\n\t            // reset the counter with a random value\n\t            game.nextArtifact = ( Math.random() * 100 ) + 100;\n\t        }\n\n\t        // spawn a new instance of Touch\n\t        // if the user has tapped the screen\n\t        if (Input.tapped) {\n\t            // keep track of taps; needed to\n\t            // calculate accuracy\n\t            game.score.taps += 1;\n\t            // add a new touch\n\t            game.entities.push(new Touch(game, Input.x, Input.y));\n\t            // set tapped back to false\n\t            // to avoid spawning a new touch\n\t            // in the next cycle\n\t            Input.tapped = false;\n\t            checkCollision = true;\n\t        }\n\n\t        // cycle through all entities and update as necessary\n\t        for (i = 0; i < game.entities.length; i += 1) {\n\t            game.entities[i].update();\n\n\t            if (game.entities[i].type === 'artifact') {\n\n\t                if (checkCollision) {\n\t                    hit = hitArtifact(game.entities[i],\n\t                                    {x: Input.x, y: Input.y, r: 7});\n\t                    if (hit) {\n\t                        // spawn an exposion\n\t                        game.addParticles(game.entities[i], 3, 7);\n\n\t                        game.score.hit += 1;\n\t                        game.entities[i].remove = true;\n\t                        game.needTutorial = false;\n\t                    }\n\t                }\n\n\t                if (game.artifactCrashed) {\n\t                    game.addParticles(game.entities[i], 4, 10);\n\t                }\n\n\t            }\n\n\t            // delete from array if remove property\n\t            // flag is set to true\n\t            if (game.entities[i].remove) {\n\t                game.entities.splice(i, 1);\n\t            }\n\t        }\n\n\t        for (n = 0; n < game.clouds.length; n++) {\n\t            game.clouds[n].update();\n\n\t            if (game.clouds[n].remove) {\n\t                game.clouds.splice(n, 1);\n\t            }\n\t        }\n\n\t        game.balloon.update();\n\t        game.pump.update();\n\n\n\t        // calculate accuracy\n\t        game.score.accuracy = (game.score.hit / game.score.taps) * 100;\n\t        game.score.accuracy = isNaN(game.score.accuracy) ?\n\t            0 :\n\t            ~~(game.score.accuracy); // a handy way to round floats\n\n\t    },\n\n\n\t    // this is where we draw all the entities\n\t    render: function() {\n\t        var i, n;\n\n\t        // фон\n\t        Draw.rect(game, 0, 0, game.WIDTH, game.HEIGHT, config.bgColor);\n\t        // земля верхний слой\n\t        Draw.rect(game, 0, game.HEIGHT - config.groundWidth, game.WIDTH, config.groundUpWidth, config.groundColorUp);\n\t        // земля нижний слой\n\t        Draw.rect(game, 0, game.HEIGHT - config.groundDownWidth, game.WIDTH, config.groundDownWidth, config.groundColorDown);\n\t        // шланг\n\t        Draw.rect(game, game.WIDTH/5 - 25 * game.imageScale, game.HEIGHT - config.groundWidth - config.hoseWidth, game.WIDTH/2 - game.WIDTH/5, config.hoseWidth, config.hoseColor);\n\t        // платформа под шариком\n\t        Draw.rect(game, game.WIDTH/2 - 25, game.HEIGHT - config.groundUpWidth - config.groundDownWidth - 10, config.platformWidth, config.platformHeight, config.hoseColor);\n\n\t        for (n = 0; n < game.clouds.length; n++) {\n\t            game.clouds[n].render();\n\t        }\n\n\t        if (game.needTutorial && game.score.total > 0) {\n\t            Draw.text(game, 'Нажимай', game.WIDTH / 4 + 70, game.HEIGHT / 3, 42, config.tutorialColor);\n\t            Draw.text(game, 'на предметы,', game.WIDTH / 4 + 40, game.HEIGHT / 3 + 48, 42, config.tutorialColor);\n\t            Draw.text(game, 'чтобы не дать им', game.WIDTH / 4, game.HEIGHT / 3 + 96, 42, config.tutorialColor);\n\t            Draw.text(game, 'коснуться шарика!', game.WIDTH / 4 - 10, game.HEIGHT / 3 + 144, 42, config.tutorialColor);\n\t        }\n\n\t        game.pump.render();\n\t        game.balloon.render();\n\n\t        // cycle through all entities and render to canvas\n\t        for (i = 0; i < game.entities.length; i += 1) {\n\t            var collides = collidesBalloon(game.entities[i], game.balloon, game);\n\t            if (collides) {\n\t                window.cancelAnimationFrame(game.animId);\n\t                // 67 balloon.pic.naturalHeight * config.balloon.minIndex (335 * 0.2)\n\t                var statusIndex = ~~(config.animalsNum * game.balloon.h / (game.HEIGHT - config.groundWidth - config.platformHeight - 67));\n\t                statusIndex = Math.min(statusIndex, config.animalsNum - 1);\n\t                window.location = 'result.html?result=' + statusIndex;\n\t            }\n\n\t            game.entities[i].render();\n\t        }\n\n\t        // display scores\n\t        Draw.text(game, 'Очки: ' + game.score.hit, 20, 32, 28, config.textColor);\n\t        Draw.text(game, 'Меткость: ' + game.score.accuracy + '%', game.WIDTH - 230, 32, 28, config.textColor);\n\t    },\n\n\n\t    // the actual loop\n\t    // requests animation frame\n\t    // then proceeds to update\n\t    // and render\n\t    loop: function() {\n\n\t        game.animId = requestAnimationFrame( game.loop );\n\n\t        game.update();\n\t        game.render();\n\t    },\n\n\t    // helper to add particles for artifacts\n\t    addParticles: function(artifact, radius, strength) {\n\t        for (var n = 0; n < 7; n +=1 ) {\n\t            game.entities.push(new Particle(\n\t                game,\n\t                artifact.x,\n\t                artifact.y,\n\t                radius,\n\t                // random opacity to spice it up a bit\n\t                'rgba(255,255,255,' + (Math.random() * 0.5 + 0.5) + ')',\n\t                strength\n\t            ));\n\t        }\n\t    },\n\n\t    restart: function() {\n\t        game.entities = [];\n\t        game.score = {\n\t            taps: 0,\n\t            hit: 0,\n\t            escaped: 0,\n\t            accuracy: 0\n\t        };\n\t        delete game.balloon;\n\t        delete game.pump;\n\t    }\n\t};\n\n\tmodule.exports = game;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t    //\n\t    // общеигровые настройки\n\t    //\n\n\t    width: 640, // ширина канваса\n\t    height: 960, // высота\n\n\t    // цвет фона\n\t    bgColor: '#45d4e0',\n\t    groundColorUp: '#00a651',\n\t    groundColorDown: '#7cc576',\n\t    hoseColor: '#f26122',\n\t    textColor: '#fff',\n\t    tutorialColor: '#fff',\n\n\t    groundUpWidth: 10,\n\t    groundDownWidth: 20,\n\t    groundWidth: 30,\n\t    hoseWidth: 4,\n\t    platformWidth: 50,\n\t    platformHeight: 10,\n\n\t    animalsNum: 14,\n\n\t    tutorialQuantity: 4,\n\n\t    // времени до появления первого артифакта (условные единицы)\n\t    firstArtifact: 100,\n\n\t    // коэффициент для синусоиды (меньше значение - дольше интервал накачивания и спускания)\n\t    timeOfBlowing: 0.5,\n\n\t    //\n\t    // настройки шарика\n\t    //\n\n\t    balloon: {\n\t        // интенсивность надувания шарика\n\t        blowingSpeed: 0.3,\n\t        // коэффициент уменьшения шарика для начала игры\n\t        minIndex: 0.2,\n\t        // коэффициент сдутия шарика (blowingSpeed * unblowingIndex)\n\t        unblowingIndex: 0.3,\n\t        // как широко будет раскачиваться\n\t        waveRange: 5\n\t    },\n\n\t    //\n\t    // настройка артифакта\n\t    //\n\n\t    artifact: {\n\t        // разброс скорости в пределах которого она может меняться\n\t        speedRange: 8,\n\t        // количество артифактов\n\t        quantity: 4,\n\t        // высота появления артифактов: heightRange * random + heightOfAppearing\n\t        heightOfAppearing: -100,\n\t        heightRange: -100,\n\t        waveRange: 20\n\t    },\n\n\t    pump: {\n\t        animationSpeed: 5,\n\t        waveRange: 30\n\t    },\n\n\t    cloud: {\n\t        speedRange: 2,\n\t        quantity: 2,\n\t        leftRange: -200,\n\t        leftOfAppearing: -300\n\t    }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t    x: 0,\n\t    y: 0,\n\t    tapped :false,\n\n\t    set: function(game, data) {\n\t        var input = this;\n\t        input.x = (data.pageX - game.offset.left) / game.scale;\n\t        input.y = (data.pageY - game.offset.top) / game.scale;\n\t        input.tapped = true;\n\t    }\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Draw = __webpack_require__(8);\n\tvar config = __webpack_require__(2);\n\n\tmodule.exports = function(game) {\n\t    var artifact = this;\n\t    \n\t    artifact.type = 'artifact';\n\n\t    artifact.speed = (Math.random() * config.artifact.speedRange) + 1;\n\n\t    if (game.score.total < config.tutorialQuantity && game.needTutorial) {\n\t        artifact.speed = 1;\n\t    }\n\n\t    artifact.remove = false;\n\n\t    // we have four types of pictures, named from 1 to 4.\n\t    var picNum = (Math.floor(Math.random() * config.artifact.quantity) + 1);\n\n\t    artifact.pic = new Image();\n\t    artifact.pic.src = './i/a' + picNum + '.png';\n\n\t    artifact.pic.onload = function() {\n\t        artifact.w = artifact.pic.naturalWidth;\n\t        artifact.h = artifact.pic.naturalHeight;\n\n\t        artifact.r = Math.min(artifact.w, artifact.h) / 2;\n\n\t        artifact.x = Math.random() * game.WIDTH - artifact.w / 2;\n\t        artifact.y = Math.random() * config.artifact.heightRange + config.artifact.heightOfAppearing;\n\n\t        // the amount by which the bubble\n\t        // will move from side to side\n\t        artifact.waveRange = config.artifact.waveRange + artifact.w / 2;\n\t        // we need to remember the original\n\t        // x position for our sine wave calculation\n\t        artifact.initX = artifact.x;\n\t    };\n\n\t    artifact.update = function() {\n\n\t        // a sine wave is commonly a function of time\n\t        var time = Date.now() * 0.002;\n\n\t        artifact.y += artifact.speed;\n\t        // the x coord to follow a sine wave\n\t        artifact.x = artifact.waveRange * Math.sin(time) + artifact.initX;\n\n\t        // if offscreen flag for removal\n\t        if (artifact.y > (game.HEIGHT - config.groundWidth - artifact.h + 10)) {\n\t            game.artifactCrashed = true;\n\t            game.score.escaped += 1; // update score\n\t            artifact.remove = true;\n\t        }\n\n\t    };\n\n\t    artifact.render = function() {\n\t        Draw.pic(game, artifact.pic, artifact.x, artifact.y, artifact.w, artifact.h);\n\t    };\n\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Draw = __webpack_require__(8);\n\tvar config = __webpack_require__(2);\n\n\tmodule.exports = function (game) {\n\t    var balloon = this;\n\n\t    balloon.type = 'balloon';\n\n\t    balloon.pic = new Image();\n\t    balloon.pic.src = './i/shar-size-1.png';\n\n\t     var groundWidth = config.groundUpWidth + config.groundDownWidth;\n\n\t    balloon.pic.onload = function () {\n\t        balloon.w = balloon.pic.naturalWidth * config.balloon.minIndex;\n\t        balloon.h = balloon.pic.naturalHeight * config.balloon.minIndex;\n\n\t        // center the balloon\n\t        balloon.x = game.WIDTH / 2 - balloon.w / 2;\n\t        balloon.y = game.HEIGHT - balloon.h - groundWidth - 10;\n\n\t        balloon.ratio = balloon.h / balloon.w;\n\t        balloon.r = balloon.w / 2; // we know that width < height\n\t        balloon.initX = balloon.x;\n\t    };\n\n\t    balloon.update = function() {\n\t        // a sine wave is commonly a function of time\n\t        var time = Date.now() * 0.002;\n\n\t        if (game.blowing) {\n\t            balloon.w += config.balloon.blowingSpeed;\n\t            balloon.h += (balloon.ratio * config.balloon.blowingSpeed);\n\t            balloon.r = balloon.w / 2;\n\t        } else {\n\t            balloon.w -= config.balloon.blowingSpeed * config.balloon.unblowingIndex;\n\t            balloon.h -= (balloon.ratio * config.balloon.blowingSpeed * config.balloon.unblowingIndex);\n\t            balloon.r = balloon.w / 2;\n\t        }\n\n\t        balloon.x = config.balloon.waveRange * Math.sin(time) + (game.WIDTH / 2 - balloon.w / 2);\n\t        balloon.y = game.HEIGHT - balloon.h - groundWidth - 10;\n\t    };\n\n\t    balloon.render = function() {\n\t        Draw.pic(game, balloon.pic, balloon.x, balloon.y, balloon.w, balloon.h);\n\t    };\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Draw = __webpack_require__(8);\n\n\tmodule.exports = function(game, x, y) {\n\t    var touch = this;\n\n\t    touch.type = 'touch';    // we'll need touch later\n\t    touch.x = x;             // the x coordinate\n\t    touch.y = y;             // the y coordinate\n\t    touch.r = 5;             // the radius\n\t    touch.opacity = 1;       // inital opacity. the dot will fade out\n\t    touch.fade = 0.1;       // amount by which to fade on each game tick\n\t    // touch.remove = false;    // flag for removing touch entity. balloon.update\n\t                            // will take care of touch\n\n\t    touch.update = function() {\n\t        // reduct the opacity accordingly\n\t        touch.opacity -= touch.fade;\n\t        // if opacity if 0 or less, flag for removal\n\t        touch.remove = (touch.opacity < 0) ? true : false;\n\t    };\n\n\t    touch.render = function() {\n\t        Draw.circle(game, touch.x, touch.y, touch.r, 'rgba(0,0,255,'+touch.opacity+')');\n\t    };\n\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Draw = __webpack_require__(8);\n\n\tmodule.exports = function(game, x, y, r, col, strength) {\n\t    var particle = this;\n\t    \n\t    particle.x = x;\n\t    particle.y = y;\n\t    particle.r = r;\n\t    particle.col = col;\n\n\t    // determines whether particle will\n\t    // travel to the right of left\n\t    // 50% chance of either happening\n\t    particle.dir = (Math.random() * 2 > 1) ? 1 : -1;\n\n\t    // random values so particles do no\n\t    // travel at the same speeds\n\t    particle.vx = ~~(Math.random() * 4) * particle.dir;\n\t    particle.vy = ~~(Math.random() * strength);\n\n\t    particle.remove = false;\n\n\t    particle.update = function() {\n\n\t        // update coordinates\n\t        particle.x += particle.vx;\n\t        particle.y -= particle.vy;\n\n\t        // increase velocity so particle\n\t        // accelerates off screen\n\t        particle.vx *= 0.99;\n\t        particle.vy *= 0.99;\n\n\t        // adding particle negative amount to the\n\t        // y velocity exerts an upward pull on\n\t        // the particle, as if drawn to the\n\t        // surface\n\t        particle.vy -= 0.25;\n\n\t        // offscreen\n\t        if (particle.y > game.HEIGHT) {\n\t            particle.remove = true;\n\t        }\n\n\t    };\n\n\t    particle.render = function() {\n\t        Draw.circle(game, particle.x, particle.y, particle.r, particle.col);\n\t    };\n\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t    clear: function() {\n\t        game.ctx.clearRect(0, 0, game.WIDTH, game.HEIGHT);\n\t    },\n\n\t    rect: function(game, x, y, w, h, col) {\n\t        game.ctx.fillStyle = col;\n\t        game.ctx.fillRect(x, y, w, h);\n\t    },\n\n\t    circle: function(game, x, y, r, col) {\n\t        game.ctx.fillStyle = col;\n\t        game.ctx.beginPath();\n\t        game.ctx.arc(x, y, r, 0,  Math.PI * 2, true);\n\t        game.ctx.closePath();\n\t        game.ctx.fill();\n\t    },\n\n\n\t    text: function(game, string, x, y, size, col) {\n\t        game.ctx.font = 'normal '+size+'px Helvetica';\n\t        game.ctx.fillStyle = col;\n\t        game.ctx.fillText(string, x, y);\n\t    },\n\n\t    pic: function (game, pic, x, y, w, h) {\n\t        game.ctx.drawImage(pic, x, y, w, h);\n\t    }\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(a, b) {\n\t    var centerArtifactX = a.x + a.w / 2;\n\t    var centerArtifactY = a.y + a.h / 2;\n\n\t    var distance_squared = ( ((centerArtifactX - b.x) * (centerArtifactX - b.x)) +\n\t                            ((centerArtifactY - b.y) * (centerArtifactY - b.y)));\n\n\t    var radii_squared = (a.r + b.r) * (a.r + b.r);\n\n\t    return distance_squared < radii_squared;\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Draw = __webpack_require__(8);\n\n\t// a - artifact\n\t// b - balloon\n\tmodule.exports = function(a, b, game) {\n\t    var centerArtifactX = a.x + a.w / 2;\n\t    var centerArtifactY = a.y + a.h - a.r;\n\n\t    // balloon center for circle\n\t    var centerBalloonX = b.x + b.r;\n\t    var centerBalloonY = b.y + b.r;\n\n\t    var distance_squared = ( ((centerArtifactX - centerBalloonX) * (centerArtifactX - centerBalloonX)) +\n\t                            ((centerArtifactY - centerBalloonY) * (centerArtifactY - centerBalloonY)));\n\n\t    var radii_squared = (a.r + b.r) * (a.r + b.r);\n\n\t//    Draw.circle(game, centerArtifactX, centerArtifactY, a.r, 'red');\n\t//    Draw.circle(game, centerBalloonX, centerBalloonY, b.r, 'blue');\n\n\t    return distance_squared - radii_squared < 20;\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Draw = __webpack_require__(8);\n\tvar config = __webpack_require__(2);\n\n\tmodule.exports = function (game) {\n\t    var pump = this;\n\n\t    pump.type = 'pump';\n\n\t    pump.pump1 = new Image();\n\t    pump.pump1.src = './i/pump1.png';\n\n\t    pump.pump2 = new Image();\n\t    pump.pump2.src = './i/pump2.png';\n\n\t    pump.pump1.onload = function () {\n\t        pump.pump1.w = pump.pump1.naturalWidth * game.imageScale;\n\t        pump.pump1.h = pump.pump1.naturalHeight * game.imageScale;\n\n\t        // use 'dx' instead of 'x' because pump.pump1 is picture object\n\t        // and already has property 'x'\n\t        pump.pump1.dx = game.WIDTH / 5 - pump.pump1.w / 2;\n\t        pump.pump1.dy = game.HEIGHT - pump.pump1.h - config.groundWidth;\n\t    };\n\n\t    pump.pump2.onload = function () {\n\t        pump.pump2.w = pump.pump2.naturalWidth * game.imageScale;\n\t        pump.pump2.h = pump.pump2.naturalHeight * game.imageScale;\n\n\t        pump.pump2.dx = game.WIDTH / 5 - pump.pump2.w / 2;\n\t        pump.pump2.dy = game.HEIGHT - pump.pump2.h - config.groundWidth;\n\t    };\n\n\t    pump.update = function() {\n\t        // a sine wave is commonly a function of time\n\t        var time = Date.now() * 0.002;\n\n\t        if (game.blowing) {\n\t            pump.pump1.dy = config.pump.waveRange * game.imageScale * Math.sin(time * config.pump.animationSpeed) +\n\t                            game.HEIGHT - pump.pump1.h - config.groundWidth - pump.pump1.w/2;\n\t        }\n\t    };\n\n\t    pump.render = function() {\n\t        Draw.pic(game, pump.pump1, pump.pump1.dx, pump.pump1.dy, pump.pump1.w, pump.pump1.h);\n\t        Draw.pic(game, pump.pump2, pump.pump2.dx, pump.pump2.dy, pump.pump2.w, pump.pump2.h);\n\t    };\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Draw = __webpack_require__(8);\n\tvar config = __webpack_require__(2);\n\n\tmodule.exports = function(game) {\n\t    var cloud = this;\n\t    \n\t    cloud.type = 'cloud';\n\n\t    cloud.speed = (Math.random() * config.cloud.speedRange) + 1;\n\n\t    if (game.score.total < config.tutorialQuantity && game.needTutorial) {\n\t        cloud.speed = 1;\n\t    }\n\n\t    cloud.remove = false;\n\n\t    // we have four types of pictures, named from 1 to 4.\n\t    var picNum = (Math.floor(Math.random() * config.cloud.quantity) + 1);\n\n\t    cloud.pic = new Image();\n\t    cloud.pic.src = './i/cloud' + picNum + '.png';\n\n\t    cloud.pic.onload = function() {\n\t        cloud.w = cloud.pic.naturalWidth;\n\t        cloud.h = cloud.pic.naturalHeight;\n\n\t        cloud.x = Math.random() * config.cloud.leftRange + config.cloud.leftOfAppearing;\n\t        cloud.y = Math.random() * (game.HEIGHT - 400);\n\t    };\n\n\t    cloud.update = function() {\n\t        cloud.x += cloud.speed;\n\n\t        // if offscreen flag for removal\n\t        if (cloud.x > game.WIDTH) {\n\t            cloud.remove = true;\n\t        }\n\n\t    };\n\n\t    cloud.render = function() {\n\t        Draw.pic(game, cloud.pic, cloud.x, cloud.y, cloud.w, cloud.h);\n\t    };\n\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 462095797e14a559096c\n **/","/**\n * RequestAnimationFrame polyfill\n */\nvar lastTime = 0;\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']\n                               || window[vendors[x]+'CancelRequestAnimationFrame'];\n}\n\nif (!window.requestAnimationFrame)\n    window.requestAnimationFrame = function(callback, element) {\n        var currTime = Date.now();\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n          timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n    };\n\nif (!window.cancelAnimationFrame)\n    window.cancelAnimationFrame = function(id) {\n        clearTimeout(id);\n    };\n\nvar game = require('./modules/game');\n\nwindow.addEventListener('load', game.init, false);\nwindow.addEventListener('resize', game.resize, false);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/app.js\n ** module id = 0\n ** module chunks = 0\n **/","var config = require('./config');\nvar Input = require('./input');\nvar Artifact = require('./artifact');\nvar Balloon = require('./balloon');\nvar Touch = require('./touch');\nvar Particle = require('./particle');\nvar Draw = require('./draw');\nvar hitArtifact = require('./hitArtifact');\nvar collidesBalloon = require('./collidesBalloon');\nvar Pump = require('./pump');\nvar Cloud = require('./cloud');\nwindow.hookjs = window.hookjs || null;\n\nvar game = {\n    // set up some inital values\n    WIDTH: config.width,\n    HEIGHT: config.height,\n    scale: 1,\n    imageScale: 1,\n    // the position of the canvas\n    // in relation to the screen\n    offset: {top: 0, left: 0},\n    // store all artifacts, touches, particles etc\n    entities: [],\n    clouds: [],\n    // the amount of game ticks until\n    // we spawn a artifact\n    nextArtifact: config.firstArtifact,\n    blowing: false,\n    needTutorial: false,\n    // for tracking player's progress\n    score: {\n        taps: 0,\n        hit: 0,\n        escaped: 0,\n        accuracy: 0,\n        total: 0\n    },\n    // we'll set the rest of these\n    // in the init function\n    RATIO:  null,\n    currentWidth:  null,\n    currentHeight:  null,\n    canvas: null,\n    ctx:  null,\n    ua:  null,\n    android: null,\n    ios:  null,\n\n    init: function() {\n        var wh = window.innerHeight;\n        var ww = window.innerWidth;\n\n        if (wh/ww > 1 && ww < 767) {\n            game.WIDTH = ww * 2;\n            game.HEIGHT = wh * 2;\n        }\n\n        if (document.location.search === '?showtutorial') {\n            game.needTutorial = true;\n        }\n\n        // will think that 640 - normal height of canvas\n        game.imageScale = Math.min(wh / 640, 1);\n\n        // the proportion of width to height\n        game.RATIO = game.WIDTH / game.HEIGHT;\n        // these will change when the screen is resize\n        game.currentWidth = game.WIDTH;\n        game.currentHeight = game.HEIGHT;\n        // this is our canvas element\n        game.canvas = document.getElementsByTagName('canvas')[0];\n        // it's important to set this\n        // otherwise the browser will\n        // default to 320x200\n        game.canvas.width = game.WIDTH;\n        game.canvas.height = game.HEIGHT;\n        // the canvas context allows us to\n        // interact with the canvas api\n        game.ctx = game.canvas.getContext('2d');\n        // we need to sniff out android & ios\n        // so we can hide the address bar in\n        // our resize function\n        game.ua = navigator.userAgent.toLowerCase();\n        game.android = game.ua.indexOf('android') > -1 ? true : false;\n        game.ios = ( game.ua.indexOf('iphone') > -1 || game.ua.indexOf('ipad') > -1  ) ? true : false;\n\n        // Шарик и насос\n        game.balloon = new Balloon(game);\n        game.pump = new Pump(game);\n\n        function addEventListener(eventType) {\n            return function (e) {\n                e.preventDefault();\n\n                if (eventType === 'touchstart') {\n                    Input.set(game, e.touches[0]);\n                } else if (eventType === 'MSPointerDown') {\n                    Input.set(game, e);\n                } else {\n                    Input.set(game, e);\n                }\n            }\n        }\n\n        var pointerDisabled = function (e) {\n            e.preventDefault();\n        };\n\n        if ('ontouchstart' in window) {\n\n            window.addEventListener('touchstart', addEventListener('touchstart'), false);\n            window.addEventListener('touchmove', pointerDisabled, false);\n            window.addEventListener('touchend', pointerDisabled, false);\n\n        } else if (window.navigator && window.navigator.msPointerEnabled) {\n\n            window.addEventListener('MSPointerDown', addEventListener('MSPointerDown'), false);\n            window.addEventListener('MSPointerMove', pointerDisabled, false);\n            window.addEventListener('MSPointerUp', pointerDisabled, false);\n\n        } else {\n\n            window.addEventListener('mousedown', addEventListener('mousedown'), false);\n            window.addEventListener('mousemove', pointerDisabled, false);\n            window.addEventListener('mouseup', pointerDisabled, false);\n\n        }\n\n\n        // we're ready to resize\n        game.resize();\n        game.loop();\n    },\n\n\n    resize: function() {\n        if (game.currentWidth > window.innerWidth) {\n            game.currentWidth = window.innerWidth;\n            game.currentHeight = game.currentWidth / game.RATIO;\n        }\n\n        if (game.android || game.ios) {\n            document.body.style.height = (window.innerHeight + 50) + 'px';\n        }\n\n        game.currentHeight = window.innerHeight;\n        // check if we in android native app\n        if (window.hookjs && window.hookjs.hideLoading) {\n            game.currentHeight -= 50;\n        }\n        // resize the width in proportion\n        // to the new height\n        game.currentWidth = game.currentHeight * game.RATIO;\n\n        // set the new canvas style width & height\n        // note: our canvas is still 320x480 but\n        // we're essentially scaling it with CSS\n        game.canvas.style.width = game.currentWidth + 'px';\n        game.canvas.style.height = game.currentHeight + 'px';\n\n        // the amount by which the css resized canvas\n        // is different to the actual (480x320) size.\n        game.scale = game.currentWidth / game.WIDTH;\n        // position of canvas in relation to\n        // the screen\n        game.offset.top = game.canvas.offsetTop;\n        game.offset.left = game.canvas.offsetLeft;\n\n        window.setTimeout(function() {\n            window.scrollTo(0,1);\n        }, 1);\n    },\n\n    // this is where all entities will be moved\n    // and checked for collisions etc\n    update: function() {\n        var i, n;\n        var checkCollision = false; // we only need to check for a collision if the user tapped on this game tick\n        var time = Date.now() * 0.002;\n\n        game.blowing = Math.sin(time * config.timeOfBlowing) > 0; // используется для синхронизации насоса и шарика\n        game.artifactCrashed = false;\n\n        // decrease our nextBubble counter\n        game.nextArtifact -= 1;\n        // if the counter is less than zero\n        if (game.nextArtifact < 0) {\n            if (game.clouds.length < 2 && !game.needTutorial) {\n                game.clouds.push(new Cloud(game));\n            }\n            // put a new instance of bubble into our entities array\n            game.entities.push(new Artifact(game));\n            game.score.total += 1;\n            // reset the counter with a random value\n            game.nextArtifact = ( Math.random() * 100 ) + 100;\n        }\n\n        // spawn a new instance of Touch\n        // if the user has tapped the screen\n        if (Input.tapped) {\n            // keep track of taps; needed to\n            // calculate accuracy\n            game.score.taps += 1;\n            // add a new touch\n            game.entities.push(new Touch(game, Input.x, Input.y));\n            // set tapped back to false\n            // to avoid spawning a new touch\n            // in the next cycle\n            Input.tapped = false;\n            checkCollision = true;\n        }\n\n        // cycle through all entities and update as necessary\n        for (i = 0; i < game.entities.length; i += 1) {\n            game.entities[i].update();\n\n            if (game.entities[i].type === 'artifact') {\n\n                if (checkCollision) {\n                    hit = hitArtifact(game.entities[i],\n                                    {x: Input.x, y: Input.y, r: 7});\n                    if (hit) {\n                        // spawn an exposion\n                        game.addParticles(game.entities[i], 3, 7);\n\n                        game.score.hit += 1;\n                        game.entities[i].remove = true;\n                        game.needTutorial = false;\n                    }\n                }\n\n                if (game.artifactCrashed) {\n                    game.addParticles(game.entities[i], 4, 10);\n                }\n\n            }\n\n            // delete from array if remove property\n            // flag is set to true\n            if (game.entities[i].remove) {\n                game.entities.splice(i, 1);\n            }\n        }\n\n        for (n = 0; n < game.clouds.length; n++) {\n            game.clouds[n].update();\n\n            if (game.clouds[n].remove) {\n                game.clouds.splice(n, 1);\n            }\n        }\n\n        game.balloon.update();\n        game.pump.update();\n\n\n        // calculate accuracy\n        game.score.accuracy = (game.score.hit / game.score.taps) * 100;\n        game.score.accuracy = isNaN(game.score.accuracy) ?\n            0 :\n            ~~(game.score.accuracy); // a handy way to round floats\n\n    },\n\n\n    // this is where we draw all the entities\n    render: function() {\n        var i, n;\n\n        // фон\n        Draw.rect(game, 0, 0, game.WIDTH, game.HEIGHT, config.bgColor);\n        // земля верхний слой\n        Draw.rect(game, 0, game.HEIGHT - config.groundWidth, game.WIDTH, config.groundUpWidth, config.groundColorUp);\n        // земля нижний слой\n        Draw.rect(game, 0, game.HEIGHT - config.groundDownWidth, game.WIDTH, config.groundDownWidth, config.groundColorDown);\n        // шланг\n        Draw.rect(game, game.WIDTH/5 - 25 * game.imageScale, game.HEIGHT - config.groundWidth - config.hoseWidth, game.WIDTH/2 - game.WIDTH/5, config.hoseWidth, config.hoseColor);\n        // платформа под шариком\n        Draw.rect(game, game.WIDTH/2 - 25, game.HEIGHT - config.groundUpWidth - config.groundDownWidth - 10, config.platformWidth, config.platformHeight, config.hoseColor);\n\n        for (n = 0; n < game.clouds.length; n++) {\n            game.clouds[n].render();\n        }\n\n        if (game.needTutorial && game.score.total > 0) {\n            Draw.text(game, 'Нажимай', game.WIDTH / 4 + 70, game.HEIGHT / 3, 42, config.tutorialColor);\n            Draw.text(game, 'на предметы,', game.WIDTH / 4 + 40, game.HEIGHT / 3 + 48, 42, config.tutorialColor);\n            Draw.text(game, 'чтобы не дать им', game.WIDTH / 4, game.HEIGHT / 3 + 96, 42, config.tutorialColor);\n            Draw.text(game, 'коснуться шарика!', game.WIDTH / 4 - 10, game.HEIGHT / 3 + 144, 42, config.tutorialColor);\n        }\n\n        game.pump.render();\n        game.balloon.render();\n\n        // cycle through all entities and render to canvas\n        for (i = 0; i < game.entities.length; i += 1) {\n            var collides = collidesBalloon(game.entities[i], game.balloon, game);\n            if (collides) {\n                window.cancelAnimationFrame(game.animId);\n                // 67 balloon.pic.naturalHeight * config.balloon.minIndex (335 * 0.2)\n                var statusIndex = ~~(config.animalsNum * game.balloon.h / (game.HEIGHT - config.groundWidth - config.platformHeight - 67));\n                statusIndex = Math.min(statusIndex, config.animalsNum - 1);\n                window.location = 'result.html?result=' + statusIndex;\n            }\n\n            game.entities[i].render();\n        }\n\n        // display scores\n        Draw.text(game, 'Очки: ' + game.score.hit, 20, 32, 28, config.textColor);\n        Draw.text(game, 'Меткость: ' + game.score.accuracy + '%', game.WIDTH - 230, 32, 28, config.textColor);\n    },\n\n\n    // the actual loop\n    // requests animation frame\n    // then proceeds to update\n    // and render\n    loop: function() {\n\n        game.animId = requestAnimationFrame( game.loop );\n\n        game.update();\n        game.render();\n    },\n\n    // helper to add particles for artifacts\n    addParticles: function(artifact, radius, strength) {\n        for (var n = 0; n < 7; n +=1 ) {\n            game.entities.push(new Particle(\n                game,\n                artifact.x,\n                artifact.y,\n                radius,\n                // random opacity to spice it up a bit\n                'rgba(255,255,255,' + (Math.random() * 0.5 + 0.5) + ')',\n                strength\n            ));\n        }\n    },\n\n    restart: function() {\n        game.entities = [];\n        game.score = {\n            taps: 0,\n            hit: 0,\n            escaped: 0,\n            accuracy: 0\n        };\n        delete game.balloon;\n        delete game.pump;\n    }\n};\n\nmodule.exports = game;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/game.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = {\n    //\n    // общеигровые настройки\n    //\n\n    width: 640, // ширина канваса\n    height: 960, // высота\n\n    // цвет фона\n    bgColor: '#45d4e0',\n    groundColorUp: '#00a651',\n    groundColorDown: '#7cc576',\n    hoseColor: '#f26122',\n    textColor: '#fff',\n    tutorialColor: '#fff',\n\n    groundUpWidth: 10,\n    groundDownWidth: 20,\n    groundWidth: 30,\n    hoseWidth: 4,\n    platformWidth: 50,\n    platformHeight: 10,\n\n    animalsNum: 14,\n\n    tutorialQuantity: 4,\n\n    // времени до появления первого артифакта (условные единицы)\n    firstArtifact: 100,\n\n    // коэффициент для синусоиды (меньше значение - дольше интервал накачивания и спускания)\n    timeOfBlowing: 0.5,\n\n    //\n    // настройки шарика\n    //\n\n    balloon: {\n        // интенсивность надувания шарика\n        blowingSpeed: 0.3,\n        // коэффициент уменьшения шарика для начала игры\n        minIndex: 0.2,\n        // коэффициент сдутия шарика (blowingSpeed * unblowingIndex)\n        unblowingIndex: 0.3,\n        // как широко будет раскачиваться\n        waveRange: 5\n    },\n\n    //\n    // настройка артифакта\n    //\n\n    artifact: {\n        // разброс скорости в пределах которого она может меняться\n        speedRange: 8,\n        // количество артифактов\n        quantity: 4,\n        // высота появления артифактов: heightRange * random + heightOfAppearing\n        heightOfAppearing: -100,\n        heightRange: -100,\n        waveRange: 20\n    },\n\n    pump: {\n        animationSpeed: 5,\n        waveRange: 30\n    },\n\n    cloud: {\n        speedRange: 2,\n        quantity: 2,\n        leftRange: -200,\n        leftOfAppearing: -300\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/config.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = {\n    x: 0,\n    y: 0,\n    tapped :false,\n\n    set: function(game, data) {\n        var input = this;\n        input.x = (data.pageX - game.offset.left) / game.scale;\n        input.y = (data.pageY - game.offset.top) / game.scale;\n        input.tapped = true;\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/input.js\n ** module id = 3\n ** module chunks = 0\n **/","var Draw = require('./draw');\nvar config = require('./config');\n\nmodule.exports = function(game) {\n    var artifact = this;\n    \n    artifact.type = 'artifact';\n\n    artifact.speed = (Math.random() * config.artifact.speedRange) + 1;\n\n    if (game.score.total < config.tutorialQuantity && game.needTutorial) {\n        artifact.speed = 1;\n    }\n\n    artifact.remove = false;\n\n    // we have four types of pictures, named from 1 to 4.\n    var picNum = (Math.floor(Math.random() * config.artifact.quantity) + 1);\n\n    artifact.pic = new Image();\n    artifact.pic.src = './i/a' + picNum + '.png';\n\n    artifact.pic.onload = function() {\n        artifact.w = artifact.pic.naturalWidth;\n        artifact.h = artifact.pic.naturalHeight;\n\n        artifact.r = Math.min(artifact.w, artifact.h) / 2;\n\n        artifact.x = Math.random() * game.WIDTH - artifact.w / 2;\n        artifact.y = Math.random() * config.artifact.heightRange + config.artifact.heightOfAppearing;\n\n        // the amount by which the bubble\n        // will move from side to side\n        artifact.waveRange = config.artifact.waveRange + artifact.w / 2;\n        // we need to remember the original\n        // x position for our sine wave calculation\n        artifact.initX = artifact.x;\n    };\n\n    artifact.update = function() {\n\n        // a sine wave is commonly a function of time\n        var time = Date.now() * 0.002;\n\n        artifact.y += artifact.speed;\n        // the x coord to follow a sine wave\n        artifact.x = artifact.waveRange * Math.sin(time) + artifact.initX;\n\n        // if offscreen flag for removal\n        if (artifact.y > (game.HEIGHT - config.groundWidth - artifact.h + 10)) {\n            game.artifactCrashed = true;\n            game.score.escaped += 1; // update score\n            artifact.remove = true;\n        }\n\n    };\n\n    artifact.render = function() {\n        Draw.pic(game, artifact.pic, artifact.x, artifact.y, artifact.w, artifact.h);\n    };\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/artifact.js\n ** module id = 4\n ** module chunks = 0\n **/","var Draw = require('./draw');\nvar config = require('./config');\n\nmodule.exports = function (game) {\n    var balloon = this;\n\n    balloon.type = 'balloon';\n\n    balloon.pic = new Image();\n    balloon.pic.src = './i/shar-size-1.png';\n\n     var groundWidth = config.groundUpWidth + config.groundDownWidth;\n\n    balloon.pic.onload = function () {\n        balloon.w = balloon.pic.naturalWidth * config.balloon.minIndex;\n        balloon.h = balloon.pic.naturalHeight * config.balloon.minIndex;\n\n        // center the balloon\n        balloon.x = game.WIDTH / 2 - balloon.w / 2;\n        balloon.y = game.HEIGHT - balloon.h - groundWidth - 10;\n\n        balloon.ratio = balloon.h / balloon.w;\n        balloon.r = balloon.w / 2; // we know that width < height\n        balloon.initX = balloon.x;\n    };\n\n    balloon.update = function() {\n        // a sine wave is commonly a function of time\n        var time = Date.now() * 0.002;\n\n        if (game.blowing) {\n            balloon.w += config.balloon.blowingSpeed;\n            balloon.h += (balloon.ratio * config.balloon.blowingSpeed);\n            balloon.r = balloon.w / 2;\n        } else {\n            balloon.w -= config.balloon.blowingSpeed * config.balloon.unblowingIndex;\n            balloon.h -= (balloon.ratio * config.balloon.blowingSpeed * config.balloon.unblowingIndex);\n            balloon.r = balloon.w / 2;\n        }\n\n        balloon.x = config.balloon.waveRange * Math.sin(time) + (game.WIDTH / 2 - balloon.w / 2);\n        balloon.y = game.HEIGHT - balloon.h - groundWidth - 10;\n    };\n\n    balloon.render = function() {\n        Draw.pic(game, balloon.pic, balloon.x, balloon.y, balloon.w, balloon.h);\n    };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/balloon.js\n ** module id = 5\n ** module chunks = 0\n **/","var Draw = require('./draw');\n\nmodule.exports = function(game, x, y) {\n    var touch = this;\n\n    touch.type = 'touch';    // we'll need touch later\n    touch.x = x;             // the x coordinate\n    touch.y = y;             // the y coordinate\n    touch.r = 5;             // the radius\n    touch.opacity = 1;       // inital opacity. the dot will fade out\n    touch.fade = 0.1;       // amount by which to fade on each game tick\n    // touch.remove = false;    // flag for removing touch entity. balloon.update\n                            // will take care of touch\n\n    touch.update = function() {\n        // reduct the opacity accordingly\n        touch.opacity -= touch.fade;\n        // if opacity if 0 or less, flag for removal\n        touch.remove = (touch.opacity < 0) ? true : false;\n    };\n\n    touch.render = function() {\n        Draw.circle(game, touch.x, touch.y, touch.r, 'rgba(0,0,255,'+touch.opacity+')');\n    };\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/touch.js\n ** module id = 6\n ** module chunks = 0\n **/","var Draw = require('./draw');\n\nmodule.exports = function(game, x, y, r, col, strength) {\n    var particle = this;\n    \n    particle.x = x;\n    particle.y = y;\n    particle.r = r;\n    particle.col = col;\n\n    // determines whether particle will\n    // travel to the right of left\n    // 50% chance of either happening\n    particle.dir = (Math.random() * 2 > 1) ? 1 : -1;\n\n    // random values so particles do no\n    // travel at the same speeds\n    particle.vx = ~~(Math.random() * 4) * particle.dir;\n    particle.vy = ~~(Math.random() * strength);\n\n    particle.remove = false;\n\n    particle.update = function() {\n\n        // update coordinates\n        particle.x += particle.vx;\n        particle.y -= particle.vy;\n\n        // increase velocity so particle\n        // accelerates off screen\n        particle.vx *= 0.99;\n        particle.vy *= 0.99;\n\n        // adding particle negative amount to the\n        // y velocity exerts an upward pull on\n        // the particle, as if drawn to the\n        // surface\n        particle.vy -= 0.25;\n\n        // offscreen\n        if (particle.y > game.HEIGHT) {\n            particle.remove = true;\n        }\n\n    };\n\n    particle.render = function() {\n        Draw.circle(game, particle.x, particle.y, particle.r, particle.col);\n    };\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/particle.js\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = {\n    clear: function() {\n        game.ctx.clearRect(0, 0, game.WIDTH, game.HEIGHT);\n    },\n\n    rect: function(game, x, y, w, h, col) {\n        game.ctx.fillStyle = col;\n        game.ctx.fillRect(x, y, w, h);\n    },\n\n    circle: function(game, x, y, r, col) {\n        game.ctx.fillStyle = col;\n        game.ctx.beginPath();\n        game.ctx.arc(x, y, r, 0,  Math.PI * 2, true);\n        game.ctx.closePath();\n        game.ctx.fill();\n    },\n\n\n    text: function(game, string, x, y, size, col) {\n        game.ctx.font = 'normal '+size+'px Helvetica';\n        game.ctx.fillStyle = col;\n        game.ctx.fillText(string, x, y);\n    },\n\n    pic: function (game, pic, x, y, w, h) {\n        game.ctx.drawImage(pic, x, y, w, h);\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/draw.js\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = function(a, b) {\n    var centerArtifactX = a.x + a.w / 2;\n    var centerArtifactY = a.y + a.h / 2;\n\n    var distance_squared = ( ((centerArtifactX - b.x) * (centerArtifactX - b.x)) +\n                            ((centerArtifactY - b.y) * (centerArtifactY - b.y)));\n\n    var radii_squared = (a.r + b.r) * (a.r + b.r);\n\n    return distance_squared < radii_squared;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/hitArtifact.js\n ** module id = 9\n ** module chunks = 0\n **/","var Draw = require('./draw');\n\n// a - artifact\n// b - balloon\nmodule.exports = function(a, b, game) {\n    var centerArtifactX = a.x + a.w / 2;\n    var centerArtifactY = a.y + a.h - a.r;\n\n    // balloon center for circle\n    var centerBalloonX = b.x + b.r;\n    var centerBalloonY = b.y + b.r;\n\n    var distance_squared = ( ((centerArtifactX - centerBalloonX) * (centerArtifactX - centerBalloonX)) +\n                            ((centerArtifactY - centerBalloonY) * (centerArtifactY - centerBalloonY)));\n\n    var radii_squared = (a.r + b.r) * (a.r + b.r);\n\n//    Draw.circle(game, centerArtifactX, centerArtifactY, a.r, 'red');\n//    Draw.circle(game, centerBalloonX, centerBalloonY, b.r, 'blue');\n\n    return distance_squared - radii_squared < 20;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/collidesBalloon.js\n ** module id = 10\n ** module chunks = 0\n **/","var Draw = require('./draw');\nvar config = require('./config');\n\nmodule.exports = function (game) {\n    var pump = this;\n\n    pump.type = 'pump';\n\n    pump.pump1 = new Image();\n    pump.pump1.src = './i/pump1.png';\n\n    pump.pump2 = new Image();\n    pump.pump2.src = './i/pump2.png';\n\n    pump.pump1.onload = function () {\n        pump.pump1.w = pump.pump1.naturalWidth * game.imageScale;\n        pump.pump1.h = pump.pump1.naturalHeight * game.imageScale;\n\n        // use 'dx' instead of 'x' because pump.pump1 is picture object\n        // and already has property 'x'\n        pump.pump1.dx = game.WIDTH / 5 - pump.pump1.w / 2;\n        pump.pump1.dy = game.HEIGHT - pump.pump1.h - config.groundWidth;\n    };\n\n    pump.pump2.onload = function () {\n        pump.pump2.w = pump.pump2.naturalWidth * game.imageScale;\n        pump.pump2.h = pump.pump2.naturalHeight * game.imageScale;\n\n        pump.pump2.dx = game.WIDTH / 5 - pump.pump2.w / 2;\n        pump.pump2.dy = game.HEIGHT - pump.pump2.h - config.groundWidth;\n    };\n\n    pump.update = function() {\n        // a sine wave is commonly a function of time\n        var time = Date.now() * 0.002;\n\n        if (game.blowing) {\n            pump.pump1.dy = config.pump.waveRange * game.imageScale * Math.sin(time * config.pump.animationSpeed) +\n                            game.HEIGHT - pump.pump1.h - config.groundWidth - pump.pump1.w/2;\n        }\n    };\n\n    pump.render = function() {\n        Draw.pic(game, pump.pump1, pump.pump1.dx, pump.pump1.dy, pump.pump1.w, pump.pump1.h);\n        Draw.pic(game, pump.pump2, pump.pump2.dx, pump.pump2.dy, pump.pump2.w, pump.pump2.h);\n    };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/pump.js\n ** module id = 11\n ** module chunks = 0\n **/","var Draw = require('./draw');\nvar config = require('./config');\n\nmodule.exports = function(game) {\n    var cloud = this;\n    \n    cloud.type = 'cloud';\n\n    cloud.speed = (Math.random() * config.cloud.speedRange) + 1;\n\n    if (game.score.total < config.tutorialQuantity && game.needTutorial) {\n        cloud.speed = 1;\n    }\n\n    cloud.remove = false;\n\n    // we have four types of pictures, named from 1 to 4.\n    var picNum = (Math.floor(Math.random() * config.cloud.quantity) + 1);\n\n    cloud.pic = new Image();\n    cloud.pic.src = './i/cloud' + picNum + '.png';\n\n    cloud.pic.onload = function() {\n        cloud.w = cloud.pic.naturalWidth;\n        cloud.h = cloud.pic.naturalHeight;\n\n        cloud.x = Math.random() * config.cloud.leftRange + config.cloud.leftOfAppearing;\n        cloud.y = Math.random() * (game.HEIGHT - 400);\n    };\n\n    cloud.update = function() {\n        cloud.x += cloud.speed;\n\n        // if offscreen flag for removal\n        if (cloud.x > game.WIDTH) {\n            cloud.remove = true;\n        }\n\n    };\n\n    cloud.render = function() {\n        Draw.pic(game, cloud.pic, cloud.x, cloud.y, cloud.w, cloud.h);\n    };\n\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./mob/js/modules/cloud.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}